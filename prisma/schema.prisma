generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

enum Role {
  SYSTEM
  ADMIN
  DEVELOPER
  DATA_ENTRY
  OBSERVER
}

enum JobStatus {
  SCHEDULED
  CANCELLED
  SUCCEEDED
  WAITING_RERUN
  WAITING
  DELAYED
  RUNNING
  STALLED
  FAILED
  PAUSED
  DRAFT
}

enum JobStepStatus {
  SUCCEEDED
  RUNNING
  WAITING_RERUN
  FAILED
}

enum Action {
  CREATE
  UPDATE
  DELETE
  OTHER
}

enum Resource {
  USER
  WORKFLOW
  OAUTH2_AUTH_STATE
  OAUTH2_TOKEN
  JOB
  SCHEDULE
  FOLDER
  WEBHOOK
  EVENT
}

enum Trigger {
  MANUAL
  WEBHOOK
  SCHEDULE
  EVENT
}

enum WebhookHashLocation {
  HEADER
  QUERY
}

enum HashAlgorithm {
  sha256
  sha512
  md5
}

model User {
  id Int @id @default(autoincrement())

  role     Role   @default(OBSERVER)
  name     String
  email    String @unique
  avatar   Bytes? @db.ByteA
  password String

  createdAt DateTime  @default(now()) @db.Timestamptz()
  updatedAt DateTime? @updatedAt @db.Timestamptz()

  Activities Activity[]
}

model Activity {
  id Int @id @default(autoincrement())

  userId Int

  resource   Resource?
  resourceId Json? // ID of the resource being acted upon (if applicable)
  action     Action
  subAction  String? // Additional action details (e.g., "rerun", "disable")
  details    Json?

  createdAt DateTime @default(now()) @db.Timestamptz()

  User     User      @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  Revision Revision?

  @@index([userId])
  @@index([resource, resourceId])
}

model Revision {
  id Int @id

  resource   Resource
  resourceId Json // ID of the target resource (e.g., Product ID)
  action     Action // Action performed on the resource (e.g., CREATE, UPDATE, DELETE)

  data  Json? // Serialized data of the resource at the time of revision
  delta Json? // Optional delta of changes made, if applicable

  createdAt DateTime @default(now()) @db.Timestamptz()

  Activity Activity @relation(fields: [id], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@index([resource, resourceId])
}

model Folder {
  id       Int  @id @default(autoincrement())
  parentId Int? // Optional parent folder ID for nested folders

  name        String
  description String?

  createdAt DateTime  @default(now()) @db.Timestamptz()
  updatedAt DateTime? @updatedAt @db.Timestamptz()

  Workflows Workflow[]
  Parent    Folder?    @relation("FolderHierarchy", fields: [parentId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  Children  Folder[]   @relation("FolderHierarchy")
}

model Workflow {
  id       Int    @id @default(autoincrement())
  folderId Int?
  key      String @unique

  active Boolean @default(true) // Indicates if the workflow is active, when inactive jobs will be kept in the queue but not executed

  createdAt DateTime  @default(now()) @db.Timestamptz()
  updatedAt DateTime? @updatedAt @db.Timestamptz()

  Jobs      Job[]
  Webhooks  Webhook[]
  Events    Event[]
  Folder    Folder?    @relation(fields: [folderId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  Schedules Schedule[]
}

model Webhook {
  id         Int @id @default(autoincrement())
  workflowId Int

  name          String
  description   String?
  token         String? // Optional token for authentication
  secret        String? // Optional secret for HMAC verification
  hashLocation  WebhookHashLocation? // Optional location for the HMAC hash (header or query)
  hashKey       String? // Which header or query parameter to use for the HMAC hash
  hashAlgorithm HashAlgorithm? // Optional hash algorithm for HMAC verification
  active        Boolean              @default(true) // Indicates if the webhook is active

  expiresAt DateTime  @db.Timestamptz()
  createdAt DateTime  @default(now()) @db.Timestamptz()
  updatedAt DateTime? @updatedAt @db.Timestamptz()

  Workflow Workflow @relation(fields: [workflowId], references: [id], onDelete: Cascade, onUpdate: Cascade)
}

model Event {
  id         Int @id @default(autoincrement())
  workflowId Int

  name       String
  provider   String? // Optional provider for the event source (e.g., "zoho", "bigCommerce")
  connection String? // Optional connection identifier for the event source
  active     Boolean @default(true) // Indicates if the event is active
  dangling   Boolean @default(false) // Indicates if the event is dangling (not linked to any workflow)

  createdAt DateTime  @default(now()) @db.Timestamptz()
  updatedAt DateTime? @updatedAt @db.Timestamptz()

  Workflow Workflow @relation(fields: [workflowId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@unique([workflowId, provider, connection, name])
}

model Schedule {
  id         Int @id @default(autoincrement())
  workflowId Int

  cronExpression    String
  oldCronExpression String? // Previous cron expression before the last update
  active            Boolean @default(true)
  dangling          Boolean @default(false)
  userDefined       Boolean @default(false) // Indicates if the schedule was created by the user
  skipNextRun       Int     @default(0) // Number of times to skip the next run

  createdAt DateTime  @default(now()) @db.Timestamptz()
  updatedAt DateTime? @updatedAt @db.Timestamptz()

  Workflow Workflow @relation(fields: [workflowId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@unique([workflowId, cronExpression])
}

model Job {
  id         Int     @id @default(autoincrement())
  parentId   Int? // Optional parent job ID for reruns
  bullId     String? @unique
  dedupeId   String?
  workflowId Int

  status       JobStatus @default(WAITING)
  trigger      Trigger   @default(MANUAL) // Which trigger initiated the job
  triggerId    String? // Identifier for the trigger (e.g., webhook ID, event, schedule ID)
  scheduledAt  DateTime? @db.Timestamptz()
  payload      Json?
  responseMeta Json?
  options      Json?

  sentryTrace   String?
  sentryBaggage String?

  createdAt DateTime  @default(now()) @db.Timestamptz()
  updatedAt DateTime? @updatedAt @db.Timestamptz()

  Workflow       Workflow?          @relation(fields: [workflowId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  Steps          JobStep[]
  ResponseChunks JobResponseChunk[]

  @@index([status])
  @@index([workflowId])
}

model JobResponseChunk {
  id    Int   @id @default(autoincrement())
  jobId Int
  data  Bytes @db.ByteA

  createdAt DateTime @default(now()) @db.Timestamptz()

  Job Job @relation(fields: [jobId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@index([jobId])
}

model JobStep {
  jobId Int
  name  String

  status  JobStepStatus @default(RUNNING)
  result  Json?
  resume  Json?
  retries Int           @default(0) // Number of retries for this step
  runs    Int           @default(1) // Number of runs for this step, both retries and reruns combined

  createdAt DateTime  @default(now()) @db.Timestamptz()
  updatedAt DateTime? @updatedAt @db.Timestamptz()

  Job Job @relation(fields: [jobId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@id([jobId, name])
}

model OAuth2AuthState {
  state    String @id
  verifier String

  provider   String
  connection String

  createdAt DateTime @default(now()) @db.Timestamptz()
}

model OAuth2Token {
  connection String
  provider   String

  access  String
  refresh String

  scopes String[]

  expiresAt DateTime  @db.Timestamptz()
  createdAt DateTime  @default(now()) @db.Timestamptz()
  updatedAt DateTime? @updatedAt @db.Timestamptz()

  @@id([provider, connection])
}

model ConnectionStatus {
  provider   String
  connection String

  working Boolean @default(true) // Indicates if the connection is working
  reason  String? // Optional reason if the connection is not working

  testedAt  DateTime? @db.Timestamptz() // Optional timestamp when the connection was last tested
  createdAt DateTime  @default(now()) @db.Timestamptz()
  updatedAt DateTime? @updatedAt @db.Timestamptz()

  @@id([provider, connection])
}
